"""
Room

Rooms are simple containers that has no location of their own.
Enhanced with AI-powered generation capabilities for Project Chimera.

"""

import sys
import os
from typing import Dict, Any, Optional, List
from evennia.objects.objects import DefaultRoom
from evennia.utils import logger

from .objects import ObjectParent

# Add chimera_core to path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))


class Room(ObjectParent, DefaultRoom):
    """
    Rooms are like any Object, except their location is None
    (which is default). They also use basetype_setup() to
    add locks so they cannot be puppeted or picked up.
    (to change that, use at_object_creation instead)

    See mygame/typeclasses/objects.py for a list of
    properties and methods available on all Objects.
    """

    pass


class GeneratedRoom(Room):
    """
    A room that was generated by the AI system.
    
    This room type includes additional metadata about its generation
    and can trigger dynamic content updates.
    """
    
    def at_object_creation(self):
        """Called when the room is first created."""
        super().at_object_creation()
        
        # Set up AI-generated room attributes
        self.db.ai_generated = True
        self.db.generation_prompt = ""
        self.db.generation_metadata = {}
        self.db.last_updated = None
        self.db.atmosphere_tags = []
        self.db.dynamic_content = True
        
        # Track room activity for AI context
        self.db.visitor_count = 0
        self.db.recent_events = []
        
        logger.log_info(f"Generated room created: {self.key}")
    
    def at_object_receive(self, moved_obj, source_location, **kwargs):
        """Called when an object enters the room."""
        super().at_object_receive(moved_obj, source_location, **kwargs)
        
        # Track visitors for AI context
        if hasattr(moved_obj, 'has_account') and moved_obj.has_account:
            self.db.visitor_count = getattr(self.db, 'visitor_count', 0) + 1
            
            # Log the visit for potential AI responses
            self._log_room_event(f"Player {moved_obj.key} entered the room")
            
            # Potentially trigger AI-driven room responses
            self._maybe_trigger_room_response(moved_obj)
    
    def at_object_leave(self, moved_obj, target_location, **kwargs):
        """Called when an object leaves the room."""
        super().at_object_leave(moved_obj, target_location, **kwargs)
        
        if hasattr(moved_obj, 'has_account') and moved_obj.has_account:
            self._log_room_event(f"Player {moved_obj.key} left the room")
    
    def _log_room_event(self, event_description: str):
        """Log an event in this room for AI context."""
        if not hasattr(self.db, 'recent_events'):
            self.db.recent_events = []
        
        # Keep only the last 10 events
        events = self.db.recent_events
        events.append({
            "description": event_description,
            "timestamp": self.db.time if hasattr(self.db, 'time') else 0
        })
        
        if len(events) > 10:
            events = events[-10:]
        
        self.db.recent_events = events
    
    def _maybe_trigger_room_response(self, entering_obj):
        """Potentially trigger an AI-driven room response."""
        # Only trigger occasionally to avoid spam
        import random
        if random.random() > 0.1:  # 10% chance
            return
        
        # Get the AI manager
        ai_manager = self._get_ai_manager()
        if not ai_manager:
            return
        
        # Generate contextual room response
        context = {
            "room_name": self.key,
            "room_description": self.db.desc or "",
            "entering_character": entering_obj.key,
            "recent_events": getattr(self.db, 'recent_events', []),
            "atmosphere_tags": getattr(self.db, 'atmosphere_tags', [])
        }
        
        prompt = f"Generate a brief atmospheric response for when {entering_obj.key} enters {self.key}. Keep it subtle and immersive."
        
        # Submit async task for room response
        ai_manager.generate_dialogue_async(
            character_obj=self,
            prompt=prompt,
            context=context,
            callback=self._handle_room_response
        )
    
    def _handle_room_response(self, result, error=None):
        """Handle the result of a room response generation."""
        if error:
            logger.log_err(f"Room response generation failed: {error}")
            return
        
        if result and isinstance(result, dict):
            response_text = result.get("text", "")
            if response_text:
                # Send atmospheric message to room
                self.msg_contents(f"|c{response_text}|n", from_obj=self)
    
    def _get_ai_manager(self):
        """Get the AI manager script."""
        from evennia import search_script
        ai_managers = search_script("ai_manager")
        return ai_managers[0] if ai_managers else None
    
    def update_from_generation_data(self, generation_data: Dict[str, Any]):
        """
        Update room properties from AI generation data.
        
        Args:
            generation_data: Dictionary containing generated room data
        """
        # Update basic properties
        if "name" in generation_data:
            self.key = generation_data["name"]
        
        if "description" in generation_data:
            self.db.desc = generation_data["description"]
        
        # Update AI-specific metadata
        if "atmosphere" in generation_data:
            self.db.atmosphere = generation_data["atmosphere"]
        
        if "tags" in generation_data:
            self.db.atmosphere_tags = generation_data["tags"]
        
        # Store generation metadata
        self.db.generation_metadata = generation_data
        self.db.last_updated = self.db.time if hasattr(self.db, 'time') else 0
        
        logger.log_info(f"Updated generated room: {self.key}")
    
    def get_ai_context(self) -> Dict[str, Any]:
        """
        Get context information about this room for AI operations.
        
        Returns:
            Dictionary containing room context
        """
        return {
            "room_name": self.key,
            "description": self.db.desc or "",
            "atmosphere": getattr(self.db, 'atmosphere', ''),
            "tags": getattr(self.db, 'atmosphere_tags', []),
            "visitor_count": getattr(self.db, 'visitor_count', 0),
            "recent_events": getattr(self.db, 'recent_events', []),
            "generation_metadata": getattr(self.db, 'generation_metadata', {}),
            "contents": [obj.key for obj in self.contents if obj.has_account]
        }
    
    def regenerate_description(self, prompt: Optional[str] = None):
        """
        Regenerate the room description using AI.
        
        Args:
            prompt: Optional specific prompt for regeneration
        """
        ai_manager = self._get_ai_manager()
        if not ai_manager:
            logger.log_err("AI Manager not available for room regeneration")
            return
        
        # Use existing context or provided prompt
        if not prompt:
            context = self.get_ai_context()
            prompt = f"Regenerate the description for {self.key} based on recent activity and atmosphere"
        
        # Submit regeneration task
        task_id = ai_manager.generate_room_async(
            prompt=prompt,
            requester=self,
            callback=self._handle_regeneration_complete
        )
        
        logger.log_info(f"Submitted room regeneration task: {task_id}")
    
    def _handle_regeneration_complete(self, result, error=None):
        """Handle completed room regeneration."""
        if error:
            logger.log_err(f"Room regeneration failed: {error}")
            return
        
        if result and isinstance(result, dict):
            self.update_from_generation_data(result)
            self.msg_contents("|yThe room seems to shift subtly around you...|n")
            logger.log_info(f"Room regeneration completed: {self.key}")
