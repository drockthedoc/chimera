"""
Pydantic schemas for game objects in Project Chimera.

These schemas define the structure for rooms, characters, items, and other
game objects that can be generated by the AI system.
"""

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, validator
from enum import Enum


class ExitDirection(str, Enum):
    """Valid exit directions for rooms."""
    NORTH = "north"
    SOUTH = "south"
    EAST = "east"
    WEST = "west"
    NORTHEAST = "northeast"
    NORTHWEST = "northwest"
    SOUTHEAST = "southeast"
    SOUTHWEST = "southwest"
    UP = "up"
    DOWN = "down"
    IN = "in"
    OUT = "out"


class ExitSchema(BaseModel):
    """Schema for room exits."""
    direction: ExitDirection = Field(..., description="Direction of the exit")
    destination: Optional[str] = Field(None, description="Key or name of destination room")
    description: Optional[str] = Field(None, description="Description of the exit")
    locked: bool = Field(False, description="Whether the exit is locked")
    hidden: bool = Field(False, description="Whether the exit is hidden")


class RoomSchema(BaseModel):
    """Schema for room generation and validation."""
    name: str = Field(..., min_length=1, max_length=100, description="Name of the room")
    description: str = Field(..., min_length=10, max_length=1000, description="Detailed description of the room")
    exits: List[ExitSchema] = Field(default_factory=list, description="Available exits from the room")
    tags: List[str] = Field(default_factory=list, description="Tags for categorizing the room")
    atmosphere: Optional[str] = Field(None, description="Atmospheric description or mood")
    items: List[str] = Field(default_factory=list, description="Items present in the room")
    npcs: List[str] = Field(default_factory=list, description="NPCs present in the room")
    properties: Dict[str, Any] = Field(default_factory=dict, description="Additional room properties")

    @validator('name')
    def validate_name(cls, v):
        """Ensure room name is properly formatted."""
        if not v.strip():
            raise ValueError("Room name cannot be empty")
        return v.strip().title()

    @validator('description')
    def validate_description(cls, v):
        """Ensure description is meaningful."""
        if len(v.strip()) < 10:
            raise ValueError("Room description must be at least 10 characters")
        return v.strip()


class CharacterPersonality(str, Enum):
    """Character personality types."""
    FRIENDLY = "friendly"
    HOSTILE = "hostile"
    NEUTRAL = "neutral"
    SHY = "shy"
    AGGRESSIVE = "aggressive"
    WISE = "wise"
    MYSTERIOUS = "mysterious"
    CHEERFUL = "cheerful"
    GRUMPY = "grumpy"


class CharacterSchema(BaseModel):
    """Schema for character/NPC generation and validation."""
    name: str = Field(..., min_length=1, max_length=50, description="Name of the character")
    description: str = Field(..., min_length=10, max_length=500, description="Physical description")
    personality: CharacterPersonality = Field(..., description="Character's personality type")
    background: str = Field(..., min_length=10, max_length=1000, description="Character's background story")
    dialogue_style: str = Field(..., description="How the character speaks")
    goals: List[str] = Field(default_factory=list, description="Character's goals or motivations")
    relationships: Dict[str, str] = Field(default_factory=dict, description="Relationships with other characters")
    skills: List[str] = Field(default_factory=list, description="Character's skills or abilities")
    inventory: List[str] = Field(default_factory=list, description="Items the character carries")
    location: Optional[str] = Field(None, description="Current location of the character")
    properties: Dict[str, Any] = Field(default_factory=dict, description="Additional character properties")

    @validator('name')
    def validate_name(cls, v):
        """Ensure character name is properly formatted."""
        if not v.strip():
            raise ValueError("Character name cannot be empty")
        return v.strip().title()


class ItemType(str, Enum):
    """Types of items in the game."""
    WEAPON = "weapon"
    ARMOR = "armor"
    TOOL = "tool"
    CONSUMABLE = "consumable"
    TREASURE = "treasure"
    BOOK = "book"
    KEY = "key"
    CONTAINER = "container"
    DECORATION = "decoration"
    MISC = "misc"


class ItemSchema(BaseModel):
    """Schema for item generation and validation."""
    name: str = Field(..., min_length=1, max_length=50, description="Name of the item")
    description: str = Field(..., min_length=10, max_length=500, description="Detailed description")
    item_type: ItemType = Field(..., description="Type/category of the item")
    value: int = Field(0, ge=0, description="Monetary value of the item")
    weight: float = Field(0.0, ge=0.0, description="Weight of the item")
    properties: Dict[str, Any] = Field(default_factory=dict, description="Special properties")
    usable: bool = Field(False, description="Whether the item can be used")
    consumable: bool = Field(False, description="Whether the item is consumed on use")
    stackable: bool = Field(False, description="Whether multiple items can stack")
    max_stack: int = Field(1, ge=1, description="Maximum stack size")

    @validator('name')
    def validate_name(cls, v):
        """Ensure item name is properly formatted."""
        if not v.strip():
            raise ValueError("Item name cannot be empty")
        return v.strip().lower()

    @validator('value')
    def validate_value(cls, v):
        """Ensure value is reasonable."""
        if v < 0:
            raise ValueError("Item value cannot be negative")
        return v


class WorldEventSchema(BaseModel):
    """Schema for world events that can be generated."""
    name: str = Field(..., description="Name of the event")
    description: str = Field(..., description="Description of what happens")
    trigger_conditions: List[str] = Field(default_factory=list, description="Conditions that trigger the event")
    effects: Dict[str, Any] = Field(default_factory=dict, description="Effects of the event")
    duration: Optional[int] = Field(None, description="Duration in game time units")
    repeatable: bool = Field(False, description="Whether the event can repeat")
    global_event: bool = Field(False, description="Whether this affects the entire world")